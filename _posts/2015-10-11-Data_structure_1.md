---
layout: post
published: True
title: Data Structure(1)
excerpt: Introduction data structrue, Stack and Que.
categories: Programming
tags: Development, Algorithm
---

**용어 정리**
------------

**자료구조**
:	자료를 저장하고 표현하는 방식

**알고리즘**
:	컴퓨터로 주어진 문제를 풀기 위한 단계적인 절차, 특정한 일을 수행하는 명령어들의 집합.

**데이터**
:	처리의 대상이 되는 모든 것

**데이터 타입**
:	데이터의 집합과 이러한 데이터에 적용할 수 있는 연산의 집합

**추상 데이터 타입(ADT:Abstarct Data Type)**
	1. 데이터 타입의 정의가 그 데이터 타입의 구현으로부터 분리된 데이터 타입을 의미.
	2. 데이터의 연산이 무엇(What)인지는 정의되지만, 데이터나 연산을 어떻게(How) 컴퓨터 상에서 구현할 것인지는 정의되지 않음.

**자료구조(Data Structure)**
---------
**"어떻게 소프트웨어 시스템의 복잡성을 관리할 것인가?"**

- **정의**
	- 추상 데이터 타입을 프로그래밍 언어로 구현한 것.
- **추상 데이터 타입**
	- 사용자들은 추상 데이터 타입이 제공하는 연산만을 사용 가능.
	- 사용자들은 제공되는 추상데이터 타입이 어떻게 사용하는지를 알아야함.
	- 사용자들은 추상 데이터 타입의 내부 데이터에 접근할 수 없다.(캡슐화)
	- 사용자들은 내부의 데이터에 접근할 수 없지만, 추상 데이터 타입을 사용할 수 있음.
	- 만약 다른 사람이 추상 데이터 타입의 구현을 변경하더라도 인터페이스가 변경되지 않으면 사용자들은 추상 데이터 타입을 같은 방식으로 사용할 수 있다.

**알고리즘(Algorithm)**
----------------
- **정의**
	- 입력 : 0개 이상의 입력이 존재하여야 한다.
	- 출력 : 1개 이상의 출력이 존재하여야 한다.
	- 명백성 : 각 명령어의 의미는 모호하지 않고 명확해야 한다.
	- 유한성 : 한정된 수의 단계 후에는 반드시 종료되어야 한다.
	- 유효성 : 각 명령어들은 실행 가능한 연산이여야 한다.
- **기술 방법**
	1. 자연어(영어, 한국어 등등)
	2. 흐름도(Flow Chart)
	3. 유사 코드(pseudo-doce)
- **성능분석**
    - 필요성
        - 처리할 데이터의 규모의 증가.
        - 상용 프로그램의 메모리 사용량 증가.
    - 측정방법
        1. 실행 시간 측정 방법(시간 복잡도)
            - 동일한 조건에서 다른 알고리즘의 연산 시간 비교
			- 사용 소프트웨어 환경, 똑같은 하드웨어 등 제약조건이 많음.
			- T(n)을 비교 [입력값 n에 대한 시간 복잡도 함수]
		2. 기억 공간 분석(공간 복잡도)
			- 알고리즘이 사용하는 기억 공간 분석.
		**보통 시간 복잡도 분석을 사용 [대부분 알고리즘이 차지하는 공간보다는 실행 시간에 더 관심이 많다.]
		특정 알고리즘이 수행하는 연산의 개수를 계산하여 알고리즘을 비교.**
	- 빅오 표기법
    	- 일반적으로 입력의 개수 n과 시간 복잡도 함수 T(n)의 관계는 상당히 복잡함.
    	- 차수가 가장 큰 항이 가장 큰 영향을 갖게 되고, 나머지 항들은 상대적으로 무시될 수 있음.

**빅오 표기법**
일반적으로 입력의 개수 n과 시간 복잡도 함수 T(n)의 관계는 상당히 복잡함.
하지만, 자료의 개수가 많을 경우에는 차수가 가장 큰 항이 가장 영향을 크게 미치고 다른 항들은 상대적으로 무시될 수 있음.

**증명**
$$
두개의 함수 f(n)과 g(n)이 주어졌을 때 모든 n>=n0에 대하여 |f(n)|<=c|g(n)|을 만족하는 2개의 상수 C와 n0가 존재하면,
f(n)=O(g(n))이다.
$$

**빅오 표기법에 따른 알고리즘의 실행 시간 비교**
$$O(1)< O(logn) < O(n) < O(nlogn) < O(n^2) < O (2^n) < O(n!)$$

**기타**
빅 오메가 표기법, 빅 세타 표기법 등이 있지만, 빅 오 표기법을 주로 사용.

**최선, 평균, 최악의 경우**
최선 : 실행 시간의 가장 적은 경우를 고려
평균 : 평균 실행 시간을 고려
최악 : 실행 시간이 가장 오래 걸리는 경우를 고려
>보통 최악의 경우를 알고리즘의 시간 복잡도 척도로 잡음.
>계산이나 경우를 계산하였을 때 최악의 경우가 가장 합리적.

**자료구조 표기법**
------------------
**이름 짓기**
1. 상수
	상수는 전체를 대문자로 표기
    	#define MAX_EMENET 100
        #define MAX_STACK_SIZE 100
2. 변수의 이름
	소문자를 사용, 언더라인을 사용하여 단어 분리.
	약어사용은 지양

    int add(ListNode *node)         // 혼동이 없는 경우
    int list_add(ListNode *node)    // 혼동이 생길 우려가 있는 경우
3. typedef의 사용
	사용자 정의 데이터 타입을 정의  

		typedef <타입의 정의><타입 이름>;

자료 구조 안의 노드의 구조 등에 대해서 이름을 부여할 때 사용.  

    	typedef int element;
        tpyedef struct ListNode{
		element data;
        struct ListNode *link;
        } ListNode;
**자료구조의 표기방법**

1. 자료구조의 요소
	자료구조는 요c소들의 집합.
    요소들은 다양한 변수값으로 정의 가능.

2. 자료 구조에 관련된 데이터
	C언어는 객체 지향이 아니라 하나의 클래스로 연산 불가
	구조체의 포인터를 전달받아 자료구조를 구현

**순환(Recursion)**
-------------------
#####순환(Recursion)은 어떤 알고리즘이나 함수가 자기 사진을 호 출하여 문제를 해결하는 프로그래밍 기법.

**example**  
```c
int factorial(int n){
	if n<1 return 1;
    else return(n * factorial(n-1));
}
```

**순환 알고리즘의 구조**
순환 알고리즘은 자기 자신을 순환적으로 호출하므로, **순환을 멈추는 부분**,**순환을 호출하는 부분**이 존재한다.

**꼬리순환(tail recursion)**: 순환 호출이 순환 함수의 맨 끝에서 이루어지는 형태의 순환.
**머리 순환(head recursion)**: 순환 호출이 순환 함수의 맨 앞에서 이루어지는 형태의 순환.

**피보나치 수열**

```c
int fib(int n){
	if(n==0) return 0;
    else if (n==1) return 1;
	else return (fib(n-1) + fib(n-2));
}
```

**하노이의 탑**

```c
void hanoi_tower(int n, char from, char tmp, char to){
	if(n==1){
	printf("%c에서 %c로 옮긴다",from,to);
    }
    else{
		hanoi_tower(n-1,from,to, tmp);
        printf("원판 %d을 %%c에서 %c로 옮긴다.",n,from,to );
        hanoi_tower(n-1, tmp,from, to);
    }
}
```

**배열, 구조체, 포인터**
-------------------
#####배열(Array)
**배열은 여러 개의 동일한 데이터 타입들의 집합**

**배열의 ADT**
create(n) ::=n개의 요소를 가진 배열의 생성
retrieve(A, i) ::== 배열A의 i번째 요소 반환
store(A,i,item) ::= 배열 A의 i번째 위치에 item저장

**배열의 응용**
1. 다항식의 덧셈
	1. ㅇㅇ
	2.
2. 희소 행렬

#####구조체(Structure)
타입이 다른 데이터들의 집합.

#####포인터(Pointer)
**다른 변수의 주소값을 저장하는 변수**

#####동적 메모리 할당(Dynamic memory allocation)
**프로그램이 실행 도중에 동적으로 메모리를 할당받는 것을 의미**

1. 리스트(List)
-------------
#####리스트(List)
**항목 간의 순서가 존재**

**리스트 ADT**
- 객체
    n개의 element형으로 구성된 순서 있는 집합
- 연산

    add_last(list, item) : 맨 끝에 요소를 추가.
    add_first(list, item) : 맨 앞에 요소를 추가.
	add(list, pos, item) : pos 위치에 있는 요소를 추가.
	delete(list, pos) : pos 위치에 있는 데이터를 제거.
    clear(list) : 리스트의 모든 요소를 제거.
    replace(list,pos,item) : pos위치의 요소를 item으로 변환.
    is_in_list(list, item) : item이 리스트 안에 있는지를 검사.
    get_entry(list, pos) : pos위치의 요소를 반환.
    get_length(list) : 리스트의 길이를 반환.
    is_empty(list) : list가 비었는지 검사.
    is_full(list) : list가 꽉 찼는지 검사.
    display(list) : 리스트의 모든 요소를 출력.


**구현**
1. 배열로 구현된 리스트
	- 구현이 간단.
	- 고정된 크기.
	- 오버헤드 발생.
2. 구조체로 구현된 리스트
	- 구현이 복잡.
	- 가변 크기.

**연결 리스트**
**물리적으로 흩어져 있는 자료들을 서로 연결하여 하나로 묶는 자료구조**
- 노드와 노드 간의 연결
- 데이터 필드와 링크 필드
-

1. 단순 연결 리스트
	- 노드들이 하나의 링크 필드를 가지며 이 링크 필드를 이용하여, 모든 노드들이 연결되어 있음.
	- 마지막 노드의 링크 필드 값은 NULL.

2. 원형 연결 리스트
	- 마지막 노드의 링크 값이 처음 노드 값을 가리킴.
3. 이중 연결 리스트
	- 이전값과 다음값으로 링크값을 두개 가짐.


2. 스택(Stack)
-------------
- 제일 먼저 입력된 데이터가 맨 아래에 쌓이는 후입선출(LIFO:Last-In First Out)구조
- 자료의 구조가 역순인 경우에 유용.
- 상자 쌓기와 유사

**push**
- 입력값을 넣음.
- 구조상 쌓이게 됨.

**pop**
- 맨위의 값을 빼냄.
- 빼낸 값을 반환.

구현방법
1. 배열로 구현
- 구현 방법이 간단
- 크기가 고정

2. 연결 리스트로 구현
- 구현 방법이 복잡
- 크기가 동적

4. 3. 큐(Queue)
-----------
####특징
1. 삽입과 삭제는 FIFO순서를 따름.
2. 삽입은 큐의 후단에서, 삭제는 전단.

####응용
1. 직접적인 응용
	- 시뮬레이션의 대기열
	- 데이터 패킷들의 모델링

####구현
- 추상 데이터 타입
	- 덱 ADT
		- create()
		- init()
		- is_empty(dq)
		- is_full(dq)
		- add_front(dq, e)
		- add_rear(dq, e)
		- delete_front(dq)
		- delete_rear(dq)
		- get_front(q)
		- get_rear(q)


####큐의 구조
- 큐의 특징
	- 큐의 전단과 후단을 관리하기 위한 2개의 변수 필요
		- front : 첫번째 요소 하나 앞의 인덱스
		- rear : 마지막 요소의 인덱스
- 큐의 상태
	- 공백상태 : front == rear
	- 포화상태 : front % M == (rear+1) % M
	- 공백상태와 포화 상태를 구별하기 위하여 하나의 공간은 항상 비워둔다.
- 큐의 연산
	- 나머지 연산을 사용하여 인덱스를 원형으로 회전 시킨다.
1. 연결된 큐
- 연결 리스트로 구현된 큐.
- front포인터는 삭제와 관련되며 rear포인터는 삽입.


덱(deqeue)
---------
####소개
**덱(deque)**은 double-ended queue의 줄임말로서 큐의 전단과 후단에서 모두 삽입과 삭제가 가능.
####구현

####응용
1. 버퍼
2. 시뮬레이션

$3+3=6
$$$3=3
