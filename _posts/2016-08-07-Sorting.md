---
layout: post
published: True
title: Sorting
excerpt: Sotring.
categories: Programming
tags: 
- Development
- Algorithm
---


## 정렬(Sorting)
	물건을 크기순으로 오름차순(ascending order)이나 내림차순(descending order)으로 나열하는 것.

### 용어
- 레코드:
	정렬 시켜야할 대상
- 필드:
	레코드의 항목
- 키:
	레코드와 레코드를 식별하는 필드.

- 단순하지만 비효율적인 방법 - 삽입 정렬, 선택 정렬 버블 정렬 등
- 복잡하지면 효율적인 방법 - 퀵 정렬, 히프 정렬, 합병 정렬, 기수 정렬 등

### 정렬의 분류
- 내부 정렬(Internal sorting)
	- 모든 데이터가 주기억장치에 저장된 상태에서 정렬.
- 외부 정렬(External sorting)
	- 외부기억장치(하드디스크)에 대부분의 데이터가 있고, 일부만 주기억장치에 저장된 상태에서 정렬.
- 안정성
	- 입력 데이터에 동일한 키 값을 갖는 레코드가 여러개 존재 할 경우, 이들 레코드들의 상대적인 위치가 정렬 후에도 변경되지 않는 것.

## 선택 정렬(Selection sort)
1. 배열의 첫번째 항목과 비교하여 최솟값을 발견한 후, 배열의 첫번째 요소와 교환
2. 첫번째 요소를 제외한 나머지 요소들 중에서 가장 작은 값을 선택하고 이를 다음 요소와 교환.
3. 이 절차를 n-1만큼 반복.

### 선택 정렬 성능 분석
- 시간 복잡도 O($n^2$)
- 안정성을 만족하지 않음.

### 선택정렬 구현

``` python
def select(data_list):
    for j in range(len(data_list)):
        mini = j

        for i in range(1+j,len(data_list)):
            if data_list[mini] > data_list[i]:
                mini = i
        data_list[mini],data_list[j] = data_list[j],data_list[mini]

    return data_list

data_list = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]

result_set = select(data_list=data_list)
print(result_set)

```
## 삽입 정렬
1. 배열의 첫번째 요소가 삽입될 위치
2. 정렬되어 있지 않은 리스트에 어느 위치에 있어야할지 판단 후, 첫 번째 요소의 값을 삽입.[정렬된 요소는 1 증가, 정렬 안된 요소는 1 감소]
3. 이 절차를 n-1만큼 반복

### 삽입 정렬 성능 분석
- 시간 복잡도O($n^2$)
- 레코드의 수가 적을 경우, 알고리즘 자체가 매우 단순하므로 복잡한 정렬 방법보다 유리.
- 어느정도 정렬되어 있는 경우에는 효율적
- 안정성을 만족.

## 버블 정렬
	인접한 배열의 값의 크기를 비교 후, 반복적으로 교환을 수행. n-1번의 수행을 통하여 리스트를 정렬.

1. 인접한 배열의 값의 크기를 비교하여 교환
2. n-1번 반복 수행.

### 버블 정렬의 성능 분석
- 시간 복잡도 O($n^2$)
- 일반적으로 자료의 교환이 자료의 이동보다 더 복잡하기 때문에, 버블 정렬을 잘 사용하지 않음.

## 셸 정렬
	기본적인 알고리즘은 삽입정렬과 유사, 간격(Gap)에 따라 리스트를 분할하고, 간격을 반으로 줄이면서 리스트를 정렬.
1. 간격을 통하여 각각의 리스트를 분리
2. 간격을 반으로 나눠가면서 배열을 정렬
3. 간격이 1이될 때까지 수행.

### 셸 정렬 성능 분석
- 연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 더 큰 거리를 이동.
교환 되는 요소들이 삽입 정렬보다는 최종 위치에 더 가까이 있을 가능성이 높음.
- 부분 리스트는 어느 정도 정렬이 된 상태이기 때문에 부분 리스트의 개수가 1이 되게하면 셸 정렬은 기본적으로 삽입 정렬을 더욱 빠르게 수행.
- 셸정렬의 시간 복잡도는 O($n^2$)이지만, 평균적으로 O($n^1.5$).

## 합병 정렬
**하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게하는 방법.**
	
1. 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할.
2. 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용.
3. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병.

### 합병 정렬의 성능 분석
- 합병단계가 $klog2n$
- 한병단계에서 최대 n번의 비교 연산이 필요.
- 총 비교 연산은 $nlog2n$번 필요.
- 최선, 최악, 평균, 최선의 경우가 다같이 O($nlog2n)인 정렬 방법.

## 퀵 정렬
- 평균적으로 매우 빠른 수행속도를 자랑하는 정렬 방법.
- 전체 리스트를 2개의 부분 리스트로 분할하고 각각의 부분 리스트를 다시 퀵정렬하는 분할 정복 방법을 사용.


1. 피벗을 기준으로 2개의 리스트로 분할.
2. 피벗의 기준으로 왼쪽과 오른쪽 값에서 순환 호출.

### 퀵 정렬 성능 분석
- $klog2n$개의 패스가 필요.
- 평균 n번 정도의 비교가 이루어지므로 퀵 정렬은 비교 연산을 총 nlog2n번 실행.
- $O(nlog_2_n)$

## 히프 정렬
	히프를 이용하면 최대 히프 혹은 최소 히프 값을 쉽게 구할 수 있으므로, 이를 이용하여 차례대로 값을 추출하여 정렬.

## 기수 정렬
- 입력 데이터에 대해 비교 연산을 실행하지 않고, 데이터를 정렬할 수 있는 방법.
- 숫자의 자릿수 값에 따라 정렬을 수행하고, 순서대로 값을 추출하여 정렬을 수행.

### 기수 정렬 성능 분석
- 시간 복잡도 O(dn)
보통 $$d<=10$$경우가 많음.
- 레코드의 키들이 동일한 길이를 가지는 숫자나 문자열로 구성되어 있어야함.

