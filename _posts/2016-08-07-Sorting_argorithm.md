---
layout: post
published: True
title: Sorting Algorithm
categories: Programming
tags: 
- Development
- Algorithm
---

## 알고리즘(Algorithm)
**컴퓨터로 주어진 문제를 풀기 위한 단계적인 절차**

### 정의
- 입력 : 0개 이상의 입력이 존재하여야 한다.
- 출력 : 1개 이상의 출력이 존재하여야 한다.
- 명백성 : 각 명령어의 의미는 모호하지 않고 명확해야 한다.
- 유한성 : 한정된 수의 단계 후에는 반드시 종료되어야 한다.
- 유효성 : 각 명령어들은 실행 가능한 연산이여야 한다.

### 기술 방법
1. 자연어(영어, 한국어 등등)
2. 흐름도(Flow Chart)
3. 유사 코드(pseudo-doce)

### 성능분석

#### 필요성
- 처리할 데이터의 규모의 증가.
- 상용 프로그램의 메모리 사용량 증가.

#### 측정방법
* 실행 시간 측정 방법(시간 복잡도)
    - 동일한 조건에서 다른 알고리즘의 연산 시간 비교
    - 사용 소프트웨어 환경, 똑같은 하드웨어 등 제약조건이 많음.
    - T(n)을 비교 [입력값 n에 대한 시간 복잡도 함수]
* 기억 공간 분석(공간 복잡도)
    - 알고리즘이 사용하는 기억 공간 분석.
    - 보통 시간 복잡도 분석을 사용 
    - 특정 알고리즘이 수행하는 연산의 개수를 계산하여 알고리즘을 비교.
    
***대부분 알고리즘이 차지하는 공간보다는 실행 시간에 더 관심이 많다.***

<!--more-->


### 빅오 표기법
- 일반적으로 입력의 개수 n과 시간 복잡도 함수 T(n)의 관계는 상당히 복잡함.
- 하지만, 자료의 개수가 많을 경우에는 차수가 가장 큰 항이 가장 영향을 크게 미치고 다른 항들은 상대적으로 무시될 수 있음.

#### 증명
두개의 함수 $$f(n)$$과 $$g(n)$$이 주어졌을 때,
모든 $$n>=n_0$$에 대하여 $$|f(n)|<=c|g(n)|$$을 만족하는 2개의 상수 $$C$$와 $$n_0$$가 존재하면,
$$f(n)=O(g(n))$$이다.


#### 빅오 표기법에 따른 알고리즘의 실행 시간 비교
$$O(1)< O(logn) < O(n) < O(nlogn) < O(n^2) < O (2^n) < O(n!)$$

#### 기타
* 빅 오메가 표기법, 빅 세타 표기법 등이 있지만, 빅 오 표기법을 주로 사용.

### 최선, 평균, 최악의 경우
* 최선 : 실행 시간의 가장 적은 경우를 고려
* 평균 : 평균 실행 시간을 고려
* 최악 : 실행 시간이 가장 오래 걸리는 경우를 고려
> 보통 최악의 경우를 알고리즘의 시간 복잡도 척도로 잡음.
> 계산이나 경우를 계산하였을 때 최악의 경우가 가장 합리적.

## 정렬(Sorting)
물건을 크기순으로 오름차순(ascending order)이나 내림차순(descending order)으로 나열하는 것.

### 용어
- 레코드:
	정렬 시켜야할 대상
- 필드:
	레코드의 항목
- 키:
	레코드와 레코드를 식별하는 필드.

- 단순하지만 비효율적인 방법 - 삽입 정렬, 선택 정렬 버블 정렬 등
- 복잡하지면 효율적인 방법 - 퀵 정렬, 히프 정렬, 합병 정렬, 기수 정렬 등

### 정렬의 분류
- 내부 정렬(Internal sorting)
	- 모든 데이터가 주기억장치에 저장된 상태에서 정렬.
- 외부 정렬(External sorting)
	- 외부기억장치(하드디스크)에 대부분의 데이터가 있고, 일부만 주기억장치에 저장된 상태에서 정렬.
- 안정성
	- 입력 데이터에 동일한 키 값을 갖는 레코드가 여러개 존재 할 경우, 이들 레코드들의 상대적인 위치가 정렬 후에도 변경되지 않는 것.

## 선택 정렬(Selection sort)
1. 배열의 첫번째 항목과 비교하여 최솟값을 발견한 후, 배열의 첫번째 요소와 교환
2. 첫번째 요소를 제외한 나머지 요소들 중에서 가장 작은 값을 선택하고 이를 다음 요소와 교환.
3. 이 절차를 n-1만큼 반복.

### 선택 정렬 성능 분석
- 시간 복잡도 $$O(n^2)$$
- 안정성을 만족하지 않음.

### 선택정렬 구현

``` python
def select(data_list):
    for j in range(len(data_list)):
        mini = j

        for i in range(1+j,len(data_list)):
            if data_list[mini] > data_list[i]:
                mini = i
        data_list[mini],data_list[j] = data_list[j],data_list[mini]

    return data_list

data_list = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]

result_set = select(data_list=data_list)
print(result_set)

```
## 삽입 정렬
1. 배열의 첫번째 요소가 삽입될 위치
2. 정렬되어 있지 않은 리스트에 어느 위치에 있어야할지 판단 후, 첫 번째 요소의 값을 삽입.[정렬된 요소는 1 증가, 정렬 안된 요소는 1 감소]
3. 이 절차를 n-1만큼 반복

### 삽입 정렬 성능 분석
- 시간 복잡도 $$O(n^2)$$
- 레코드의 수가 적을 경우, 알고리즘 자체가 매우 단순하므로 복잡한 정렬 방법보다 유리.
- 어느정도 정렬되어 있는 경우에는 효율적
- 안정성을 만족.

## 버블 정렬
인접한 배열의 값의 크기를 비교 후, 반복적으로 교환을 수행. n-1번의 수행을 통하여 리스트를 정렬.

1. 인접한 배열의 값의 크기를 비교하여 교환
2. n-1번 반복 수행.

### 버블 정렬의 성능 분석
- 시간 복잡도 $$O(n^2)$$
- 일반적으로 자료의 교환이 자료의 이동보다 더 복잡하기 때문에, 버블 정렬을 잘 사용하지 않음.

## 셸 정렬
기본적인 알고리즘은 삽입정렬과 유사, 간격(Gap)에 따라 리스트를 분할하고, 간격을 반으로 줄이면서 리스트를 정렬.
1. 간격을 통하여 각각의 리스트를 분리
2. 간격을 반으로 나눠가면서 배열을 정렬
3. 간격이 1이될 때까지 수행.

### 셸 정렬 성능 분석
- 연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 더 큰 거리를 이동.
교환 되는 요소들이 삽입 정렬보다는 최종 위치에 더 가까이 있을 가능성이 높음.
- 부분 리스트는 어느 정도 정렬이 된 상태이기 때문에 부분 리스트의 개수가 1이 되게하면 셸 정렬은 기본적으로 삽입 정렬을 더욱 빠르게 수행.
- 셸정렬의 시간 복잡도는 $$O(n^2)$$이지만, 평균적으로 $$O(n^1.5)$$.

## 합병 정렬
하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게하는 방법.
	
1. 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할.
2. 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용.
3. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병.

### 합병 정렬의 성능 분석
- 합병단계가 $$klog2n$$
- 한병단계에서 최대 n번의 비교 연산이 필요.
- 총 비교 연산은 $nlog2n$번 필요.
- 최선, 최악, 평균, 최선의 경우가 다같이 $$O(n*log2n)$$인 정렬 방법.

## 퀵 정렬
- 평균적으로 매우 빠른 수행속도를 자랑하는 정렬 방법.
- 전체 리스트를 2개의 부분 리스트로 분할하고 각각의 부분 리스트를 다시 퀵정렬하는 분할 정복 방법을 사용.


1. 피벗을 기준으로 2개의 리스트로 분할.
2. 피벗의 기준으로 왼쪽과 오른쪽 값에서 순환 호출.

### 퀵 정렬 성능 분석
- $$k*log2n$$개의 패스가 필요.
- 평균 n번 정도의 비교가 이루어지므로 퀵 정렬은 비교 연산을 총 $$n*log2n$$번 실행.

## 히프 정렬
히프를 이용하면 최대 히프 혹은 최소 히프 값을 쉽게 구할 수 있으므로, 이를 이용하여 차례대로 값을 추출하여 정렬.

## 기수 정렬
- 입력 데이터에 대해 비교 연산을 실행하지 않고, 데이터를 정렬할 수 있는 방법.
- 숫자의 자릿수 값에 따라 정렬을 수행하고, 순서대로 값을 추출하여 정렬을 수행.

### 기수 정렬 성능 분석
- 시간 복잡도 O(dn)
보통 $$d<=10$$경우가 많음.
- 레코드의 키들이 동일한 길이를 가지는 숫자나 문자열로 구성되어 있어야함.

