---
layout: post
published: True
title: Data Structure(2)
excerpt: Introduction Tree and Sotring.
categories: Programming
tags: 
- Development
- Algorithm
---

자료구조 정리(2)
=========

####용어 정리
정점(Vertex) 
: 위치 개념

간선(Edge)
: 위치 간의 관계인 다리

오일러 경로(Eulerian tour)
: 모든 경로를 한번만 통과하여 처음 정점으로 되돌아오는 경로.

무방향 그래프(Undirected graph) 
: 간선에 방향성이 없는 그래프.

방향 그래프(Directed graph) 
: 간선에 방향성이 있는 그래프.

가중치 그래프(Weighted graph) 
: 간선에 비용아니 가중치가 할당된 그래프.

차수(Degree) 
: 무방향그래 하나의 정점에 인접한 정점의 수

진입 차수(In-degree) 
: 밖에서 한 정점으로 들어오는 간선의 수

진출 차수(Out-degree) 
: 한 정점에서 나가는 모든 간선의 수


###트리(tree)
#### 정의
- 노드와 간선을 이용하여 계층적으로 구성한 자료구조의 종류.
- 나무를 거꾸로 뒤집은 형태와 비슷하여 트리라고 불림.

#### 특징
- 계층적인 구조를 나타내기 위한 자료구조.
- 조직 구조, 디렉토리 구조 등에 사용.

#### 용어
- 노드(Node)
	- 트리를 구성하고 있는 각각의 구성 요소.
- 루트 노드(Root Node)
	- 트리의 최상단에 있는 노드.
- 서브트리(Sub Tree)
	- 트리를 제외한 나머지 노드들.
- 간선(Edge)
	- 노드 간의 연결선.
- 차수(Degree)
	- 특정 노드가 가지고 있는 자식 노드의 개수.
- 레벨(Level)
	- 각 층에 대한 번호.
	- 맨위가 1층.
- 포리스트(Forest)

#### 노드간의 관계
- 부모 노드(Parent Node)
	- 바로 아래 레벨에 간선으로 연결된 노드.
- 자식 노드(Children Node)
	- 바로 위 레벨에 간선으로 연결된 노드.
- 형제 관계(Sibling)
	- 같은 부모 노드를 가진 노드들간의 관계.
- 조상 노드(Ancestor Node)
	- 루트 노드에서 임의의 노드까지의 경로를 이루고 있는 노드들.
- 자손 노드(Descendent Node)
	- 임의의 노듸 하위에 연결된 모든 노드들.
- 단말 노드(Terminal Node)
	- 자식 노드가 없는 노드.
- 비단말 노드(Nonterminal Node)
	- 자식 노드가 있는 노드.

#### 이진 트리
##### 정의
- 공집합이거나 루트의 왼쪽 서브 트리, 오른쪽 서브 트리로 구성된 노드들의 유한 집합으로 정의.
- 이진 트리의 서브 트리들은 모두 이진 트리.

##### 특징
- 트리 중 가장 많이 쓰이는 트리.
- 모든 트리의 차수는 2이하.
- 왼쪽 서브트리와 오른쪽 서브트리로 구별.

##### 성질
- 루트를 제외한 나머지 노드들은 하나의 부모 노드를 가짐.
- 부모와 자식 간에는 하나의 간선만이 존재.
- n개의 노드를 가진 이진트리는 n-1개의 간선을 가짐.
- 높이가 h인 이진 트리의 경우, 최대 $$2^h-1$$개의 노드를 가질 수 있다.

##### 이진 트리의 분류
1. 포화 이진 트리(Full binary tree)
	- 트리의 각 레벨에 노드가 꽉 차 있는 이진 트리.
2. 완전 이진 트리(Complete binary tree)
	- 높이가 k일 때, 레벨 1부터 k-1까지는 노드가 모두 채워져 있고, 마지막 레벨 k에서는 왼쪽부터 오른쪽으로 노드가 순서대로 채워져있는 이진 트리.
	- 포화 이진 트리는 항상 완전 이진트리(역은 성립하지 않음.)
3. 기타 이진 트리(ETC binary tree)
	- 경사 이진 트리

##### 이진트리의 구현
1. 배열 표현법
- 포화 이진 트리나 완전 이진 트리의 경우 자주 쓰임.
- 일반적인 이진 트리의 경우에는 메모리 공간 낭비가 심함.
>노드 i의 부모 노드 인덱스 = i/2
>노드 i의 왼쪽 자식 노드 인덱스 = 2*i
>노드 i의 오른쪽 자식노드 인덱스 = 2*i+1

2. 링크 리스트 표현법
- 노드가 구조체로 구현되고, 각 노드가 포인터를 이용하여 노드와 노드를 연결.
- 하나의 노드가 데이터를 저장하는 필드와 왼쪽, 오른쪽 자식노드를 가르키는 2개의 포인터 필드를 가짐.

##### 이진 트리의 순회
	순회: 이진 트리에 속하는 모든 노드를 한 번씩 방문하여 노드가 가지고 있는 데이터를 목적에 맞게 처리하는 것을 의미.
- 전위 순회(preorder travelsal) : VLR
	- 루트, 왼쪽 서브트리, 오른쪽 서브트리 순으로 방문.
- 중위 순회(inorder traversal) : LVR
	- 왼쪽 서브트리, 루트, 오른쪽 서브트리 순으로 방문.
- 후위 순회(postorder traversal) : LRV
	- 왼쪽 서브트리, 오른쪽 서브트리, 루트 순으로 방문.
- 트리 레벨 순회
	- 각 노드를 레벨순으로 검사.

##### 이진 트리의 연산
- 노드의 개수
	- 순회를 통하여 전체 각 노드의 수를 합함.
- 높이 구하기
	- 서브 트리의 값을 비교하여 가장 큰 값을 높이로 선택.

#### 이진 탐색 트리
	이진 트리 기반의 탐색을 위한 자료구조

###### 용어
- 탐색(Search)
	- 집합에서 특정한 레코드를 찾아내는 작업
- 필드(Field)
- 테이블(Table)
- 주요키(Primary Key)
	- 각각의 레코드를 구분하기 위하여 사용하는 고유의 값.

##### 이진 탐색 트리의 정의
- 모든 노드의 키는 유일.
- 왼쪽 서브 트리의 키들은 루트의 키보다 작음.
- 오른쪽 서브 트리의 키들은 루트의 키보다 큼.
- 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리로 구성.

##### 이진 탐색 트리의 탐색 알고리즘
1. 이진 탐색 트리가 공백상태이면 복귀.
2. 키값과 현재 트리의 값이 같으면 루트를 반환.

##### 이진 탐색 트리의 삽입 연산
- 트리 T에 값에 대한 탐색을 먼저 수행.
- 탐색이 실패하면 끝난 지점에 값을 삽입.

##### 이진 탐색 트리의 삭제 연산
1. 값을 탐색
2. 삭제하려는 노드에 대한 검사
	- 삭제하려는 노드가 단말노드일 경우
		- 값을 바로 삭제
	- 삭제하려는 노드가 하나의 서브 트리만 갖는 경우
		- 값을 삭제 후, 하위 노드의 값을 위로 올림.
	- 삭제하려는 노드가 두 개의 서브 트리를 갖는 경우
		- 값을 삭제 후, 왼쪽 서브 트리에서 제일 큰 값 혹은 오른쪽 서브트리에서 제일 작은 값과 교환.

##### 이진 탐색 트리의 분석
- 이진 탐색 트리에서의 탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이와 같다. O(h)
- 높이=log2n=log2 15=4

### 우선순위 큐
	데이터에 우선순위를 부여하여, 우선순위에 따라 값을 보냄.

| 자료 구조  | 삭제되는 요소 				|
|-------|--------------					|
| 스택  | 가장 최근에 들어온 데이터 			|
| 큐 | 가장 먼저 들어온 데이터  			|
| 우선순위 큐  | 가장 우선순위가 높은 데이터   |

#### 우선 순위 큐의 구현
##### 연결 리스트를 사용
- 삽입의 시간 복잡도 O(1)
- 삭제의 시간 복잡도 O(n)

##### 히프를 사용
	히프(Heap)는 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조.
	여러 개의 값들 중에서 가장 큰값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조.
	부모 노드의 키값이 자식 노드의 키값보다 항상 큰(작은) 이진트리를 의미.
	Key(A)>=key(B)
	값의 중복을 허용함.

###### 최대 히프(Max Heap)
- 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리.
key(부모 노드) >= key(자식 노드)
- 루트 노드의 값이 최댓값

###### 최소 히프(Min Heap)
- 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리.
key(부모 노드) <= key(자식 노드)
- 루트 노드의 값이 최솟값

###### 히프의 삽입 연산
- 번호 순으로 가장 마지막 위치에 새로운 값 삽입.
- 부모노드의 값과 비교해가며, 교환을 반복 수행.

###### 히프의 삭제 연산
- 루트 노드의 값을 삭제
- 가장 밑단의 값을 루트 노드로 변경.
- 새로운 루트 노드값에 대하여 교환을 반복 수행.

시간 복잡도는 log2 n

###### 허프만 코드
	각 글자의 빈도가 알려져 있는 메시지의 내용을 압축하는데 사용

#### 정렬(Sorting)
	물건을 크기순으로 오름차순(ascending order)이나 내림차순(descending order)으로 나열하는 것.

##### 용어
- 레코드:
	정렬 시켜야할 대상
- 필드:
	레코드의 항목
- 키:
	레코드와 레코드를 식별하는 필드.

- 단순하지만 비효율적인 방법 - 삽입 정렬, 선택 정렬 버블 정렬 등
- 복잡하지면 효율적인 방법 - 퀵 정렬, 히프 정렬, 합병 정렬, 기수 정렬 등

##### 정렬의 분류
- 내부 정렬(Internal sorting)
	- 모든 데이터가 주기억장치에 저장된 상태에서 정렬.
- 외부 정렬(External sorting)
	- 외부기억장치(하드디스크)에 대부분의 데이터가 있고, 일부만 주기억장치에 저장된 상태에서 정렬.
- 안정성
	- 입력 데이터에 동일한 키 값을 갖는 레코드가 여러개 존재 할 경우, 이들 레코드들의 상대적인 위치가 정렬 후에도 변경되지 않는 것.

##### 선택 정렬(Selection sort)
1. 배열의 첫번째 항목과 비교하여 최솟값을 발견한 후, 배열의 첫번째 요소와 교환
2. 첫번째 요소를 제외한 나머지 요소들 중에서 가장 작은 값을 선택하고 이를 다음 요소와 교환.
3. 이 절차를 n-1만큼 반복.

###### 선택 정렬 성능 분석
- 시간 복잡도 O($n^2$)
- 안정성을 만족하지 않음.

##### 삽입 정렬
1. 배열의 첫번째 요소가 삽입될 위치
2. 정렬되어 있지 않은 리스트에 어느 위치에 있어야할지 판단 후, 첫 번째 요소의 값을 삽입.[정렬된 요소는 1 증가, 정렬 안된 요소는 1 감소]
3. 이 절차를 n-1만큼 반복

###### 삽입 정렬 성능 분석
- 시간 복잡도O($n^2$)
- 레코드의 수가 적을 경우, 알고리즘 자체가 매우 단순하므로 복잡한 정렬 방법보다 유리.
- 어느정도 정렬되어 있는 경우에는 효율적
- 안정성을 만족.

##### 버블 정렬
	인접한 배열의 값의 크기를 비교 후, 반복적으로 교환을 수행. n-1번의 수행을 통하여 리스트를 정렬.

1. 인접한 배열의 값의 크기를 비교하여 교환
2. n-1번 반복 수행.

###### 버블 정렬의 성능 분석
- 시간 복잡도 O($n^2$)
- 일반적으로 자료의 교환이 자료의 이동보다 더 복잡하기 때문에, 버블 정렬을 잘 사용하지 않음.

##### 셸 정렬
	기본적인 알고리즘은 삽입정렬과 유사, 간격(Gap)에 따라 리스트를 분할하고, 간격을 반으로 줄이면서 리스트를 정렬.
1. 간격을 통하여 각각의 리스트를 분리
2. 간격을 반으로 나눠가면서 배열을 정렬
3. 간격이 1이될 때까지 수행.

###### 셸 정렬 성능 분석
- 연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 더 큰 거리를 이동.
교환 되는 요소들이 삽입 정렬보다는 최종 위치에 더 가까이 있을 가능성이 높음.
- 부분 리스트는 어느 정도 정렬이 된 상태이기 때문에 부분 리스트의 개수가 1이 되게하면 셸 정렬은 기본적으로 삽입 정렬을 더욱 빠르게 수행.
- 셸정렬의 시간 복잡도는 O($n^2$)이지만, 평균적으로 O($n^1.5$).

##### 합병 정렬
	하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게하는 방법.
1. 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할.
2. 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용.
3. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병.

###### 합병 정렬의 성능 분석
- 합병단계가 $klog2n$
- 한병단계에서 최대 n번의 비교 연산이 필요.
- 총 비교 연산은 $nlog2n$번 필요.
- 최선, 최악, 평균, 최선의 경우가 다같이 O($nlog2n)인 정렬 방법.

##### 퀵 정렬
	평균적으로 매우 빠른 수행속도를 자랑하는 정렬 방법.
    전체 리스트를 2개의 부분 리스트로 분할하고 각각의 부분 리스트를 다시 퀵정렬하는 분할 정복 방법을 사용.

1. 피벗을 기준으로 2개의 리스트로 분할.
2. 피벗의 기준으로 왼쪽과 오른쪽 값에서 순환 호출.

###### 퀵 정렬 성능 분석
- $klog2n$개의 패스가 필요.
- 평균 n번 정도의 비교가 이루어지므로 퀵 정렬은 비교 연산을 총 nlog2n번 실행.
- $O(nlog_2_n)$

##### 히프 정렬
	히프를 이용하면 최대 히프 혹은 최소 히프 값을 쉽게 구할 수 있으므로, 이를 이용하여 차례대로 값을 추출하여 정렬.
##### 기수 정렬
	입력 데이터에 대해 비교 연산을 실행하지 않고, 데이터를 정렬할 수 있는 방법.
    숫자의 자릿수 값에 따라 정렬을 수행하고, 순서대로 값을 추출하여 정렬을 수행.

###### 기수 정렬 성능 분석
- 시간 복잡도 O(dn)
보통 $$d<=10$$경우가 많음.
- 레코드의 키들이 동일한 길이를 가지는 숫자나 문자열로 구성되어 있어야함.

#### 그래프(Graph)
	연결되어 있는 객체 간의 관계를 표현할 수 있는 자료 구조